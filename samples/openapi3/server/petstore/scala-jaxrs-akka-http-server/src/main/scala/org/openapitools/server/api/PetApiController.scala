/**
* OpenAPI Petstore
* This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
*
* The version of the OpenAPI document: 1.0.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

package org.openapitools.server.api

import org.openapitools.server.model.ApiResponse
import java.io.File
import org.openapitools.server.model.Pet
import scala.concurrent.{ExecutionContext, Future}
import akka.http.scaladsl.marshalling.ToResponseMarshaller
import akka.http.scaladsl.unmarshalling.FromRequestUnmarshaller
import akka.http.scaladsl.model.Multipart
import akka.stream.scaladsl.StreamConverters
import akka.stream.Materializer
import akka.http.scaladsl.model.Multipart.BodyPart
import akka.stream.scaladsl.FileIO
import scala.concurrent.duration._
import akka.http.scaladsl.model.StatusCodes
import scala.util.Success
import spray.json._

class PetApiController(api: PetApiSpec[Future])
  (implicit ec: ExecutionContext, materializer: Materializer) extends AbstractApi {

  import org.openapitools.server.model.ModelFormats._

  override def routes = pathPrefix("pet") { 
    pathSingleSlash { 
      post { extractRequest { request =>      
          entity(as[Pet]) { pet =>
      
      
      
         onComplete( api.addPet(pet) ) {
            case Success(result) => complete(StatusCodes.NoContent)
         }
      
      
       } 
    }}} ~ 
    path( LongNumber ) { (petId)  =>
      delete { extractRequest { request =>      
      
          val apiKey = request.headers.find(p => p.is("apiKey")).head.asInstanceOf[String]
      
      
      
         onComplete( api.deletePet(petId, apiKey) ) {
            case Success(result) => complete(StatusCodes.NoContent)
         }
      
      
      
    }}} ~ 
    path( "findByStatus") { 
      get { extractRequest { request =>
      
      
      
      parameters('status.as[String].*) { (status) => 
         onComplete( api.findPetsByStatus(status) ) {
            case Success(result) => complete(result)
         }
       } 
      
      
    }}} ~ 
    path( "findByTags") { 
      get { extractRequest { request =>
      
      
      
      parameters('tags.as[String].*, 'maxCount.as[Int]) { (tags, maxCount) => 
         onComplete( api.findPetsByTags(tags, maxCount) ) {
            case Success(result) => complete(result)
         }
       } 
      
      
    }}} ~ 
    path( LongNumber ) { (petId)  =>
      get { extractRequest { request =>
      
      
      
      
         onComplete( api.getPetById(petId) ) {
            case Success(result) => complete(result)
         }
      
      
      
    }}} ~ 
    pathSingleSlash { 
      put { extractRequest { request =>      
          entity(as[Pet]) { pet =>
      
      
      
         onComplete( api.updatePet(pet) ) {
            case Success(result) => complete(StatusCodes.NoContent)
         }
      
      
       } 
    }}} ~ 
    path( LongNumber ) { (petId)  =>
      post { extractRequest { request =>      
      
      
          entity(as[Multipart.FormData]) { formData =>
            val allParts: Future[Map[String, Any]]= formData.parts.mapAsync[(String, Any)](1){
                case b: BodyPart =>
                  b.toStrict(2.seconds).map(strict => b.name -> strict.entity.data.utf8String)
          }.runFold(Map.empty[String, Any])((map, tuple) => map + tuple)
          onSuccess(allParts) { allParts =>
                val name = allParts("name").asInstanceOf[String]
                val status = allParts("status").asInstanceOf[String]
      
      
         onComplete( api.updatePetWithForm(petId, name, status) ) {
            case Success(result) => complete(StatusCodes.NoContent)
         }
      
       }} 
      
    }}} ~ 
    path( LongNumber  / "uploadImage") { (petId)  =>
      post { extractRequest { request =>
      
      
      
          entity(as[Multipart.FormData]) { formData =>
            val allParts: Future[Map[String, Any]]= formData.parts.mapAsync[(String, Any)](1){
                case b: BodyPart if b.name == "file" =>
                  val file = File.createTempFile("upload", "tmp")
                  b.entity.dataBytes.runWith(FileIO.toPath(file.toPath)).map(_ => b.name -> file)
                case b: BodyPart =>
                  b.toStrict(2.seconds).map(strict => b.name -> strict.entity.data.utf8String)
          }.runFold(Map.empty[String, Any])((map, tuple) => map + tuple)
          onSuccess(allParts) { allParts =>
                val additionalMetadata = allParts("additionalMetadata").asInstanceOf[String]
                val file = allParts("file").asInstanceOf[File]
      
      
         onComplete( api.uploadFile(petId, additionalMetadata, file) ) {
            case Success(result) => complete(result)
         }
      
       }} 
      
    }}}
  }
}
