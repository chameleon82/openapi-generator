{{>spec/licenseInfo}}
package {{package}}

{{#imports}}import {{import}}
{{/imports}}
import scala.concurrent.{ExecutionContext, Future}
import akka.http.scaladsl.marshalling.ToResponseMarshaller
import akka.http.scaladsl.unmarshalling.FromRequestUnmarshaller
import akka.http.scaladsl.model.Multipart
import akka.stream.scaladsl.StreamConverters
import akka.stream.Materializer
import akka.http.scaladsl.model.Multipart.BodyPart
import akka.stream.scaladsl.FileIO
import scala.concurrent.duration._
import akka.http.scaladsl.model.StatusCodes
import scala.util.Success
import spray.json._

{{#operations}}
class {{classname}}Controller(api: {{classname}}Spec[Future])
  (implicit ec: ExecutionContext, materializer: Materializer) extends AbstractApi {

  import {{modelPackage}}.ModelFormats._

  override def routes = pathPrefix("{{{baseName}}}") { {{#operation}}
    {{{vendorExtensions.x-path}}} { {{#hasPathParams}}({{#pathParams}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/pathParams}})  =>{{/hasPathParams}}
      {{vendorExtensions.x-akka-httpMethod-directive}} { extractRequest { request =>{{^vendorExtensions.x-scala-is-response-unit}}
       {{/vendorExtensions.x-scala-is-response-unit}}
      {{#hasBodyParam}}{{#bodyParam}}
          entity(as[{{dataType}}]) { {{paramName}} =>{{/bodyParam}}{{/hasBodyParam}}
      {{#hasHeaderParams}}{{#headerParams}}
          val {{paramName}} = request.headers.find(p => p.is("{{paramName}}")).head.asInstanceOf[{{dataType}}]
      {{/headerParams}}{{/hasHeaderParams}}
      {{#hasFormParams}}{{#vendorExtensions.x-multipart}}
          entity(as[Multipart.FormData]) { formData =>
            val allParts: Future[Map[String, Any]]= formData.parts.mapAsync[(String, Any)](1){
            {{#formParams}}
            {{#isFile}}
                case b: BodyPart if b.name == "{{paramName}}" =>
                  val file = File.createTempFile("upload", "tmp")
                  b.entity.dataBytes.runWith(FileIO.toPath(file.toPath)).map(_ => b.name -> file)
            {{/isFile}}
            {{/formParams}}
                case b: BodyPart =>
                  b.toStrict(2.seconds).map(strict => b.name -> strict.entity.data.utf8String)
          }.runFold(Map.empty[String, Any])((map, tuple) => map + tuple)
          onSuccess(allParts) { allParts =>
            {{#formParams}}
                val {{paramName}} = allParts("{{paramName}}").asInstanceOf[{{dataType}}]
            {{/formParams}}
      {{/vendorExtensions.x-multipart}}{{^vendorExtensions.x-multipart}}formFields({{#formParams}}'{{paramName}}{{#hasMore}}, {{/hasMore}}{{/formParams}}) { ({{#formParams}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/formParams}}) => {{/vendorExtensions.x-multipart}}{{/hasFormParams}}
      {{#hasQueryParams}}parameters({{#queryParams}}'{{paramName}}.{{^isContainer}}as[{{{dataType}}}]{{/isContainer}}{{#isContainer}}as[{{{baseType}}}].*{{/isContainer}}{{#hasMore}}, {{/hasMore}}{{/queryParams}}) { ({{#queryParams}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/queryParams}}) => {{/hasQueryParams}}
         onComplete( api.{{operationId}}({{#allParams}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) ) {
            case Success(result) => complete({{^vendorExtensions.x-scala-is-response-unit}}result{{/vendorExtensions.x-scala-is-response-unit}}{{#vendorExtensions.x-scala-is-response-unit}}StatusCodes.NoContent{{/vendorExtensions.x-scala-is-response-unit}})
         }
      {{#hasQueryParams}} } {{/hasQueryParams}}
      {{#hasFormParams}}{{#vendorExtensions.x-multipart}} }}{{/vendorExtensions.x-multipart}}{{^vendorExtensions.x-multipart}} } {{/vendorExtensions.x-multipart}} {{/hasFormParams}}
      {{#hasBodyParam}} } {{/hasBodyParam}}
    }}}{{#hasMore}} ~ {{/hasMore}}{{/operation}}
  }
}
{{/operations}}
